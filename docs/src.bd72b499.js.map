{"version":3,"sources":["graph.js","move.js","render.js","index.js"],"names":["initialCells","Array","fill","undefined","map","_","i","MIN_CELL","MAX_CELL","borderLeft","borderRight","cellN","calculateGraph","cells","cell","left","right","top","down","isLeft","includes","isRight","isTop","isDown","edges","filter","edge","vertex","initialGraph","move","graph","find","length","vertexes","emptyIndex","indexOf","cellIndex","splice","render","grid","document","querySelector","innerHTML","cellElement","createElement","className","classList","add","dataset","forEach","appendChild","clickHandler","newGraph","Number","querySelectorAll","addEventListener","e","target","randomGenerator","Math","floor","random","startButton","start","intervalId","setInterval","setTimeout","clearInterval","removeEventListener"],"mappings":"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","file":"src.bd72b499.js","sourceRoot":"../src","sourcesContent":["const initialCells = Array(16).fill(undefined).map((_, i) => i);\n\nexport const MIN_CELL = 0;\nexport const MAX_CELL = 15;\nconst borderLeft = [0, 4, 8, 12];\nconst borderRight = borderLeft.map(cellN => cellN + 3);\n\nexport const calculateGraph = cells => cells.map((cell, i) => {\n    const left = i - 1;\n    const right = i + 1;\n    const top = i - 4;\n    const down = i + 4;\n    const isLeft = borderLeft.includes(i);\n    const isRight = borderRight.includes(i);\n    const isTop = top < MIN_CELL;\n    const isDown = down > MAX_CELL;\n    let edges = [cells[left], cells[right], cells[top], cells[down]];\n    if(isTop) {\n        edges = edges.filter(edge => edge !== cells[top]);\n    }\n    if(isDown) {\n        edges = edges.filter(edge => edge !== cells[down]);\n    }\n    if(isRight) {\n        edges = edges.filter(edge => edge !== cells[right]);\n    }\n    if(isLeft) {\n        edges = edges.filter(edge => edge !== cells[left]);\n    }\n    return {\n        vertex: cells[i],\n        edges\n    };\n});\n\nexport const initialGraph = calculateGraph(initialCells);\n\n/*\n* todo Нужна функция, которая принимает список HTML-элементов и возвращает новый граф\n*      так мы будем знать, куда переехала новая вершина и какие у неё соседи\n* */\n","import {calculateGraph, MAX_CELL, MIN_CELL} from './graph';\n\nexport const move = (cell, graph) => {\n    if(cell > MAX_CELL || cell < MIN_CELL) {\n        return null;\n    }\n    const cellVertex = graph.find(vertex => vertex.vertex === cell);\n    const hasEmptyCell = cellVertex.edges.filter(edge => edge === 0).length > 0;\n    if(!hasEmptyCell) {\n        return null;\n    }\n    const vertexes = graph.map(vertex => vertex.vertex);\n    const emptyIndex = vertexes.indexOf(0);\n    const cellIndex = vertexes.indexOf(cell);\n    vertexes.splice(emptyIndex, 1, cell);\n    vertexes.splice(cellIndex, 1, 0);\n    return calculateGraph(vertexes);\n};\n","export const render = graph => {\n    if(graph === null) {\n        return null;\n    }\n    const grid = document.querySelector('.grid');\n    grid.innerHTML = '';\n    const cells = graph.map(vertex => vertex.vertex);\n    const cellElements = cells.map(cell => {\n        const cellElement = document.createElement('div');\n        cellElement.className = `cell cell${cell}`;\n        if(cell === 0) {\n            cellElement.classList.add('empty');\n            cellElement.innerHTML = '';\n        }\n        cellElement.dataset.cell = cell;\n        return cellElement;\n    });\n    cellElements.forEach(cellElement => {\n        grid.appendChild(cellElement);\n    });\n};\n","import {initialGraph} from './graph';\nimport {move} from './move';\nimport {render} from './render';\n\nlet graph = initialGraph;\n\nconst clickHandler = (cell) => {\n    const newGraph = move(Number(cell), graph);\n    if (!newGraph) {\n        return null;\n    }\n    graph = newGraph;\n    render(graph);\n    const cells = [...document.querySelectorAll('.cell')];\n    cells.forEach(cellElement => {\n        cellElement.addEventListener('click', e => {\n            clickHandler(e.target.dataset.cell);\n        });\n    })\n};\nconst randomGenerator = () => Math.floor(Math.random() * 16);\n\nrender(graph);\n\nconst startButton = document.querySelector('.empty');\n\nconst start = () => {\n    const intervalId = setInterval(() => {\n        clickHandler(randomGenerator());\n    }, 10);\n\n    setTimeout(() => {\n        clearInterval(intervalId);\n    }, 5000);\n    startButton.removeEventListener('click', start);\n};\n\nstartButton.addEventListener('click', start);\n\nconst cells = [...document.querySelectorAll('.cell')];\ncells.forEach(cellElement => {\n    cellElement.addEventListener('click', e => {\n        clickHandler(e.target.dataset.cell);\n    });\n});\n"]}